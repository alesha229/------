import asyncio
import logging
from aiogram import Bot, Dispatcher, types
from aiogram.filters.command import Command
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from sqlalchemy.orm import selectinload
from aiohttp import web
from datetime import datetime
from aiogram.fsm.storage.memory import MemoryStorage

import config
from models import Base, User, Subscription
from handlers import admin, subscription, referral
from utils.monitoring import start_monitoring, log_command
from parsers.search_aggregator import SearchAggregator
from webhook_server import app as webhook_app
from database import engine, async_session_maker, DatabaseMiddleware
from keyboards.subscription import get_subscription_keyboard
from keyboards.main import get_main_keyboard

# Configure logging
logging.basicConfig(level=getattr(logging, config.LOG_LEVEL))
logger = logging.getLogger(__name__)

# Initialize bot and dispatcher
bot = Bot(token=config.BOT_TOKEN)
dp = Dispatcher(storage=MemoryStorage())  # –î–æ–±–∞–≤–ª—è–µ–º —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –¥–ª—è FSM

# Add middleware
dp.update.middleware(DatabaseMiddleware())

# Register routers
dp.include_router(admin.router)
dp.include_router(subscription.router)
dp.include_router(referral.router)

# Initialize parsers
search_aggregator = SearchAggregator()

# –°–æ–∑–¥–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è FSM
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext

class SearchStates(StatesGroup):
    waiting_for_part_number = State()

@dp.message(Command("start"))
@log_command
async def cmd_start(message: types.Message, session: AsyncSession):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start"""
    # –°–æ–∑–¥–∞–µ–º –∏–ª–∏ –ø–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    result = await session.execute(
        select(User)
        .options(selectinload(User.subscription))
        .where(User.telegram_id == message.from_user.id)
    )
    user = result.scalar_one_or_none()
    
    if not user:
        # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user = User(
            telegram_id=message.from_user.id,
            username=message.from_user.username,
            first_name=message.from_user.first_name,
            last_name=message.from_user.last_name
        )
        session.add(user)
        await session.commit()
        
        # –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—É—é –ø–æ–¥–ø–∏—Å–∫—É –Ω–∞ 1 –¥–µ–Ω—å
        from datetime import datetime, timedelta
        trial_subscription = Subscription(
            user_id=user.id,
            is_active=True,
            start_date=datetime.utcnow(),
            period='trial',
            end_date=datetime.utcnow() + timedelta(days=1),
            is_trial=True
        )
        session.add(trial_subscription)
        await session.commit()
    
    await message.answer(
        f"–ü—Ä–∏–≤–µ—Ç, {message.from_user.first_name}! üëã\n\n"
        f"–Ø –ø–æ–º–æ–≥—É —Ç–µ–±–µ –Ω–∞–π—Ç–∏ –∞–≤—Ç–æ–∑–∞–ø—á–∞—Å—Ç–∏ –ø–æ –ª—É—á—à–∏–º —Ü–µ–Ω–∞–º.\n"
        f"–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏:",
        reply_markup=get_main_keyboard()
    )

@dp.message(lambda message: message.text == "üîç –ü–æ–∏—Å–∫ –∑–∞–ø—á–∞—Å—Ç–µ–π")
@log_command
async def search_parts(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ –ø–æ–∏—Å–∫–∞ –∑–∞–ø—á–∞—Å—Ç–µ–π"""
    await state.set_state(SearchStates.waiting_for_part_number)
    await message.answer(
        "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –¥–µ—Ç–∞–ª–∏ –¥–ª—è –ø–æ–∏—Å–∫–∞.\n"
        "–ù–∞–ø—Ä–∏–º–µ—Ä: 90915YZZD4"
    )

@dp.message(SearchStates.waiting_for_part_number)
@log_command
async def handle_part_number(message: types.Message, session: AsyncSession, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤–≤–æ–¥–∞ –Ω–æ–º–µ—Ä–∞ –¥–µ—Ç–∞–ª–∏"""
    await state.clear()
    part_number = message.text.strip()
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–ø–∏—Å–∫—É
    result = await session.execute(
        select(User)
        .options(selectinload(User.subscription))
        .where(User.telegram_id == message.from_user.id)
    )
    user = result.scalar_one_or_none()
    
    if not user or not user.subscription:
        keyboard = get_subscription_keyboard()
        await message.answer(
            "–î–ª—è –ø–æ–∏—Å–∫–∞ –∑–∞–ø—á–∞—Å—Ç–µ–π –Ω–µ–æ–±—Ö–æ–¥–∏–º–∞ –ø–æ–¥–ø–∏—Å–∫–∞.\n"
            "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∞—Ä–∏—Ñ –¥–ª—è –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è –ø–æ–¥–ø–∏—Å–∫–∏:",
            reply_markup=keyboard
        )
        return
        
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –ø–æ–¥–ø–∏—Å–∫–∏
    now = datetime.utcnow()
    subscription = user.subscription
    if not subscription.is_active or subscription.end_date < now:
        subscription.is_active = False
        await session.commit()
        
        keyboard = get_subscription_keyboard()
        await message.answer(
            "–í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –∏—Å—Ç–µ–∫–ª–∞.\n"
            "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∞—Ä–∏—Ñ –¥–ª—è –ø—Ä–æ–¥–ª–µ–Ω–∏—è –ø–æ–¥–ø–∏—Å–∫–∏:",
            reply_markup=keyboard
        )
        return
    
    status_message = await message.answer("üîç –ò—â–µ–º –∑–∞–ø—á–∞—Å—Ç—å –Ω–∞ –≤—Å–µ—Ö –ø–ª–æ—â–∞–¥–∫–∞—Ö... –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è.")
    
    try:
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∞–≥—Ä–µ–≥–∞—Ç–æ—Ä –¥–ª—è –ø–æ–∏—Å–∫–∞ –Ω–∞ –≤—Å–µ—Ö –ø–ª–æ—â–∞–¥–∫–∞—Ö
        results = await search_aggregator.search_all(part_number)
        
        # –ü–æ–ª—É—á–∞–µ–º –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ —Ü–µ–Ω–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
        sorted_results = search_aggregator.sort_results_by_price(results)
        
        logging.info(f"Search results for {part_number}: {sorted_results}")
        
        if not any(results.values()):  # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ö–æ—Ç—å –Ω–∞ –æ–¥–Ω–æ–π –ø–ª–æ—â–∞–¥–∫–µ
            await status_message.edit_text(
                "üòï –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –∑–∞–ø—á–∞—Å—Ç–∏ —Å —Ç–∞–∫–∏–º –Ω–æ–º–µ—Ä–æ–º –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –Ω–∏ –Ω–∞ –æ–¥–Ω–æ–π –ø–ª–æ—â–∞–¥–∫–µ.\n"
                "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –Ω–æ–º–µ—Ä–∞ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
            )
            return
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏
        response = "üîç –ù–∞–π–¥–µ–Ω–Ω—ã–µ –∑–∞–ø—á–∞—Å—Ç–∏ (–æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã –ø–æ —Ü–µ–Ω–µ):\n\n"
        
        # –í—ã–≤–æ–¥–∏–º —Ç–æ–ø-5 —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Å –∫–∞–∂–¥–æ–π –ø–ª–æ—â–∞–¥–∫–∏
        for i, item in enumerate(sorted_results[:15], 1):
            delivery_info = f"üì¶ –î–æ—Å—Ç–∞–≤–∫–∞: {item.get('delivery_days', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')} –¥–Ω." if item.get('delivery_days') is not None else ""
            price = item.get('price', 0)
            price_str = f"{price:,.0f}".replace(",", " ") if price else "–ù–µ —É–∫–∞–∑–∞–Ω–∞"
            quantity = item.get('in_stock', 0)
            in_stock = f"‚úÖ –í –Ω–∞–ª–∏—á–∏–∏: {quantity} —à—Ç." if quantity > 0 else "‚ùå –ù–µ—Ç –≤ –Ω–∞–ª–∏—á–∏–∏"
            
            response += (
                f"{i}. {item.get('part_name', '–ù–∞–∑–≤–∞–Ω–∏–µ –Ω–µ —É–∫–∞–∑–∞–Ω–æ')}\n"
                f"üìù –ê—Ä—Ç–∏–∫—É–ª: {item.get('part_number', '–ù–µ —É–∫–∞–∑–∞–Ω')}\n"
                f"üè≠ –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å: {item.get('brand', '–ù–µ —É–∫–∞–∑–∞–Ω')}\n"
                f"üí∞ –¶–µ–Ω–∞: {price_str} ‚ÇΩ\n"
                f"üè™ –ú–∞–≥–∞–∑–∏–Ω: {item.get('source', '–ù–µ —É–∫–∞–∑–∞–Ω')}\n"
                f"{in_stock}\n"
                f"{delivery_info}\n"
                f"üîó {item.get('url', '')}\n\n"
            )
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –ø–ª–æ—â–∞–¥–∫–∞–º
        response += "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–∏—Å–∫–∞:\n"
        for source, items in results.items():
            response += f"{source}: –Ω–∞–π–¥–µ–Ω–æ {len(items)} –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π\n"
        
        await status_message.edit_text(response)
        
    except Exception as e:
        logging.error(f"Error searching parts: {e}", exc_info=True)
        await status_message.edit_text(
            "üòî –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ.\n"
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É."
        )

async def main():
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    # –ó–∞–ø—É—Å–∫ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
    await start_monitoring()

    # –ó–∞–ø—É—Å–∫ –≤–µ–±—Ö—É–∫ —Å–µ—Ä–≤–µ—Ä–∞
    runner = web.AppRunner(webhook_app)
    await runner.setup()
    site = web.TCPSite(runner, '0.0.0.0', 8080)
    await site.start()
    logger.info("Webhook server started on port 8080")

    # –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
    await dp.start_polling(bot)

if __name__ == '__main__':
    asyncio.run(main())
